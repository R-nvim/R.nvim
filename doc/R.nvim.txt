*R.nvim.txt*                                             Plugin to work with R

Authors: R.nvim team (see: https://github.com/R-nvim)

Version: 0.9.0
For Neovim >= 0.10.4

 1. Overview                                    |R.nvim-overview|
 2. Main features                               |R.nvim-features|
 3. Installation                                |R.nvim-installation|
 4. Use                                         |R.nvim-use|
 5. Known bugs and workarounds                  |R.nvim-known-bugs|
 6. Options                                     |R.nvim-options|
 7. Public Lua API                              |R.nvim-lua-api|
 8. Custom key bindings                         |R.nvim-key-bindings|
 9. History                                     |R.nvim-history|


==============================================================================
1. Overview                                                  *R.nvim-overview*

This plugin improves the support for editing R code with Neovim.

Feedback is welcomed. Please submit bug reports to the developers. Do not like
a feature? Tell us and we may add an option to disable it.

The plugin should emit useful warnings if you do things it was not programmed
to deal with. Cryptic error message are bugs... Please report them at:

    https://github.com/jalvesaq/Nvim-R/discussions

Git pull requests are welcome.


==============================================================================
2. Main features                                             *R.nvim-features*

  * Integrated communication with R:
      - Start/Close R.
      - Send lines, selection, paragraphs, functions, blocks, entire file.
      - Send commands with the object under cursor as argument: help, args,
        plot, print, str, summary, example, names.
      - Send to R the Sweave, knit and LaTeX commands.
  * Auto completion (with `cmp-r`):
      - R objects (.GlobalEnv and loaded packages).
      - function arguments.
      - knitr chunk options.
      - Quarto cell options.
  * Ability to see R's documentation in an editor buffer:
      - Automatic formatting of the text to fit the panel width.
      - Send code and commands to R (useful to run examples).
      - Jump to another R documentation.
      - See R documentation formatted as Rmd.
  * Object Browser (.GlobalEnv and loaded packages):
      - Tree view of objects.
      - Send commands with the object under cursor as argument.
      - Call R's `help()` with the object under cursor as argument.
      - Syntax highlighting of the Object Browser.
  * SyncTeX support for Rnoweb.
  * Special highlighting for R output (.Rout files).
  * Limited support for debugging R functions.
  * Get the `params` variable from Quarto and Rmd YAML header and Create and
    update the corresponding `params` list in `.GlobalEnv`.
  * Most of the plugin's behavior is customizable.



==============================================================================
3. Installation                                          *R.nvim-installation*

The installation process is described in four sections:

   3.1. Installation of dependencies
   3.2. Installation of the plugin
   3.3. Troubleshooting
   3.4. Optional steps


------------------------------------------------------------------------------
3.1. Installation of dependencies

Before installing the plugin, you should install its dependencies:

Main dependencies:

   Neovim >= 0.10.4:
      https://github.com/neovim/neovim/releases
      See also: https://github.com/neovim/neovim/wiki/Installing-Neovim

   nvim-treesitter:
      https://github.com/nvim-treesitter/nvim-treesitter
      You have to enable highlighting by tree-sitter and install parsers for
      `r`, `markdown`, `markdown_inline`, `rnoweb`, `yaml`, `latex`, and `csv`.

   cmp-r (for auto-completion):
      https://github.com/R-nvim/cmp-r

   R >= 4.0.0:
      http://www.r-project.org/

   Make and C compiler
      GNU `make` and a C compiler (e.g. `gcc` or `clang`) must be installed to
      build the the R package `nvimcom` which is included in R.nvim and is
      automatically installed and updated whenever necessary.
      On Windows, you have to install Rtools to be able to build `nvimcom`:
      https://cran.r-project.org/bin/windows/Rtools/

      Note about the R package `nvimcom`:

      You do not need to load nvimcom in your .Rprofile because the R.nvim
      plugin sets the environment variable `R_DEFAULT_PACKAGES`, including
      `nvimcom` in the list of packages to be loaded on R startup. However,
      if you set the option `defaultPackages` in a .Rprofile, you should
      include "nvimcom" among the packages to be loaded (see
      |nvimcom-not-loaded|).

   Quarto: required to complete chunk options in `#|` comments in Quarto, Rmd
      and Rnoweb documents: https://quarto.org/

   The R packages:
      - `knitr`: to generate final documents from Rnoweb, Rmd or Quarto.
      - `quarto`: to generate final documents from Quarto.
      - `rmarkdown`: to generate final documents from Rmd.
      - `styler`: to format R code.

Additional dependencies for editing Rnoweb documents:

   latexmk: Automate the compilation of LaTeX documents.
            See examples in |latexcmd|.

   PDF viewer with SyncTeX support and capable of automatically reloading
   documents. This is required only if you edit Rnoweb files.
      On Linux and other Unix systems: Zathura.
      On macOS: Skim.
      On Windows: SumatraPDF.

Suggestions for Unix (Linux, macOS, etc.):

   Tmux >= 3.0:  http://tmux.sourceforge.net
                 Tmux is required only if you want to run R in an external
		 terminal emulator or in a Tmux split panel
		 (see |external_term|).

   colorout >= 1.3-1:
                 https://github.com/jalvesaq/colorout/releases
                 Colorizes the R output in terminal emulators.
                 (Mostly useful if running R in an external terminal emulator.
                 See |external_term|). You should put in your Rprofile:
                 `library(colorout)`

Suggestions for bibliographic completion from Zotero in RMarkdown (`.Rmd`) and
Quarto (`.qmd`) documents:

   - https://github.com/jalvesaq/zotcite
   - https://github.com/jalvesaq/cmp-zotcite


------------------------------------------------------------------------------
3.2. Installation of the plugin

It is recommended that you use a plugin manager to install R.nvim. See the
Wiki:

   https://github.com/R-nvim/R.nvim/wiki


------------------------------------------------------------------------------
3.3. Troubleshooting (if the plugin doesn't work)

Note: The <LocalLeader> is '\' by default.

The plugin is a |file-type| plugin. It will be active only if you are editing
a .R, .Rnw, .Rd, .Rmd or .qmd file. The key bindings will not be active while
editing either unnamed files or files with name extensions other than the
mentioned above: However, see:

  https://github.com/jalvesaq/Nvim-R/wiki/Enable-Nvim-R-for-any-file-type

If the plugin is active, pressing <LocalLeader>rf should start R.

Did you see warning messages but they disappeared before you have had time to
read them? Type the command |:messages| in Normal mode to see them again.

Run `:checkhealth r` to check if some dependencies are installed and if
treesitter is working properly.

Run `:RDebugInfo` to see information useful to fix some common issues.

To see on the R Console messages received by `nvimcom`, put in your
`~/.Rprofile`:
>r
  options(nvimcom.verbose = 5)
<
If R does not start with the <LocalLeader>rf command and you get an error
message instead, you may want to set the path to the R executable (see
|R_path|).
                                                          *nvimcom-not-loaded*
If you see the following message in the R console:
>
   During startup - Warning messages:
   1: In library(package, lib.loc = lib.loc, character.only = TRUE,
                 logical.return = TRUE, : there is no package called ‘nvimcom’
   2: package ‘nvimcom’ in options("defaultPackages") was not found
<
Try quitting both R and Neovim and starting them again.

If you still see the message "The package nvimcom wasn't loaded yet" after
starting R, then R.nvim could not induce R to load nvimcom. R.nvim sets the
environment variable `R_DEFAULT_PACKAGES` before starting R. If the variable
already exists, the string ",nvimcom" is appended to it. However, if you set
the option `defaultPackages` in your .Rprofile or in a .Rprofile in the
current directory, the environment variable will be overridden. Thus, if you
have to set the option `defaultPackages`, you should include "nvimcom" among
the packages to be loaded. You might want to include "nvimcom" only if R was
started by R.nvim, as in the example below:
>r
   if(Sys.getenv("RNVIM_TMPDIR") == ""){
       options(defaultPackages = c("utils", "grDevices", "graphics",
                                   "stats", "methods"))
   } else {
       options(defaultPackages = c("utils", "grDevices", "graphics",
                                   "stats", "methods", "nvimcom"))
   }
<
Finally, run the command `:RDebugInfo` after <LocalLeader>rf and check the
path where nvimcom was installed.

On Windows, nvimcom compilation will fail if your `.Rprofile` outputs anything
during R Startup. It will also fail with a message about `--slave` not being a
`gcc` option if either `make.exe` or `gcc.exe` from RTools are not the first
ones found in your systems' `PATH` (see |R_path| and |Rtools-path|).


------------------------------------------------------------------------------
3.4. Optional steps

The plugin should work without the need of any configuration right after
installed, but if you do not like how the plugin works, you could look at the
section |R.nvim-options| to see if there is an option that could make you
happier.

You can also install additional plugins to get other useful functionalities to
edit R code. Please, access R.nvim's wiki:

   https://github.com/R-nvim/R.nvim/wiki


==============================================================================
4. Use                                                            *R.nvim-use*

By default, R.nvim will run R in a built-in terminal emulator, but you can
change this behavior (see |external_term|).


------------------------------------------------------------------------------
4.1. Key bindings

Note: The <LocalLeader> is '\' by default.

To use the plugin, open a .R, .Rnw, .Rd, .Rmd or .qmd file with Neovim
and type <LocalLeader>rf. Then, you will be able to use the plugin key
bindings to send commands to R.

The default key binding to quit R is <LocalLeader>rq, but if you quit Neovim
with R still running in a Neovim's built-in terminal emulator, R.nvim will
send to R the command `quit(save = "no")` (see the |auto_quit| option).

This plugin has many key bindings. Not all key bindings are enabled in all
file types supported by the plugin (r, rnoweb, rhelp, rmd, and quarto).
To see the list of mappings, do in Normal mode:
>vim
   :RMapsDesc
<
Please see |R.nvim-key-bindings| to learn how to customize the key bindings.

R syntax uses " <- " to assign values to variables which is inconvenient to
type. In insert mode, typing <M--> will write " <- ". Note: You can't map
<C-=> to `<Plug>RInsertAssign` because in Neovim only alphabetic letters can
be mapped in combination with the CTRL key.

In Rnoweb files, if the cursor is in an empty line in Insert mode, pressing
`<M-r>`  will insert `<<>>=\n@`. If the line is not empty, it will insert
`\Sexpr{}`. You can map the "less than" symbol to `<Plug>RnwInsertChunk` to
emulate Nvim-R behavior.

In Rmd and Quarto files, typing <M-r> in Insert mode will insert chunk
delimiters. In addition to creating an empty chunk block, the key strokes will
be converted to inline R delimiters if the cursor is not at the beginning of
the line. You can map a single backtick to `<Plug>RmdInsertChunk` to emulate
the default behavior of Nvim-R.

The plugin commands that send code to R Console are the most commonly used. If
the code to be sent to R has a single line it is sent directly to R Console.
If it has more than one line (a selection of lines, a block of lines between
two marks, a paragraph etc) and if the number of lines is higher than
|max_paste_lines|, the lines are written to a file and the plugin sends to R
the command to source the file. To send to R Console the line currently under
the cursor you should type <LocalLeader>d. See the option `source_args` If you
want to see what lines are being sourced when sending a selection of lines.
The <LocalLeader>m{motion} command sends the lines from the motion command
that follows <LocalLeader>m, e.g. <LocalLeader>m} (from the current line to
the end of paragraph) or <LocalLeader>m3j (the next 3 lines including the
current one).

If the cursor is between manually inserted marks (a-z), the plugin will send
the lines between them to R if you press <LocalLeader>bb. If the cursor is
above the first mark, the plugin will send from the beginning of the file to
the mark. If the cursor is below the last mark, the plugin will send from the
mark to the end of the file. The mark above the cursor is included and the
mark below is excluded from the block to be sent to R. To create a mark, press
m<letter> in Normal mode (see |mark|). For example, consider the following
code (with line numbers):
>
   1
   2  x <- 3
   3  y <- 2
   4
   5  z <- x + y
   6

In Normal mode, go to line 2 and press `ma`; go to line 6 and press `mb`; go
to line 4 and press `<LocalLeader>bb` to send lines 2 to 5 to R. Normally, Vim
marks are not visible, but there are plugins that highlight them.

Sending a selection of lines is actually a special case of sending a marked
block with the marks being `'<` and `'>`. That is the reason why the command
to send selection also works in Normal mode: it will send the lines that
were selected for the last time.

You can also use the command `:RSend` to type and, then, send a line of code
to R.

The command <LocalLeader>o runs in the background the R command `print(line)`,
where `line` is the line under the cursor, and adds the output as commented
lines to the source code.

If the cursor is over the header of an R chunk with the `child` option (from
Rnoweb, RMarkdown, Quarto or RreStructuredText document), and you use one of
the commands that send a single line of code to R, then the plugin will send
to R the command to knit the child document.

After the commands that send, sweave or knit the current buffer, Neovim will
save the current buffer if it has any pending changes before performing the
tasks. After <LocalLeader>ao, Neovim will run "R CMD BATCH --no-restore
--no-save" on the current file and show the resulting .Rout file in a new tab.
Please see |routnotab| if you prefer that the file is open in a new split
window. Note: The command <LocalLeader>ao, silently writes the current buffer
to its file if it was modified and deletes the .Rout file if it exists.

When you press <LocalLeader>rh, the plugin shows the help for the function
under the cursor formatted as a `rmd` file. The plugin also checks the class
of the first object passed as argument to the function to try to figure out
whether the function is a generic one and whether it is more appropriate to
show a specific method. The same procedure is followed with <LocalLeader>rp,
that is, while printing an object. For example, if you run the code below and,
then, press <LocalLeader>rh and <LocalLeader>rp over the two occurrences of
`summary`, the plugin will show different help documents and print different
function methods in each case:
>r
   y <- rnorm(100)
   x <- rnorm(100)
   m <- lm(y ~ x)
   summary(x)
   summary(m)
<
To get help on an R topic, you can also type in Neovim (Normal mode):
>vim
   :RHelp topic
<
You may close the R documentation window by simply pressing `q`. R
documentation is open in a 'modifiable' buffer to allow you to edit the
code in the "Examples" section. Press `<LocalLeader>`gn to jump to the
next section of R code ("Usage" or "Examples" section) and use R.nvim
key bindings to send code to the R Console.

The command <LocalLeader>td will run `dput()` with the object under cursor as
argument and insert the output in a new tab. The command <LocalLeader>rv will
also run `dput()` with the object under cursor as argument and show the output
in a new tab, while <LocalLeader>vs will show it in a horizontal split, and
<LocalLeader>vv will show it in a vertical split. However, if the object under
the cursor is a data.frame or a matrix, instead of displaying the output of
`dput()`, the commands will save the data.frame or matrix in a text file with
values separated by tab characters and display this file. The command
<LocalLeader>vh will show the `head()` of the data.frame or matrix in a
horizontal split that opens above the current window. This behavior can be
customized, and you can configure R.nvim to call an external application to
display the data.frame or matrix (see |view_df|). All files involved in these
operations are created in R.nvim's temporary directory and deleted when R
quits.

You can source all .R files in a directory with the Normal mode command
`:RSourceDir`, which accepts an optional argument (the directory to be
sourced).

In Normal mode `:RStop` sends to R SIGINT which is the same signal sent when
you press CTRL-C into R's Console. If R does not quit normally, you can kill
it with the `:RKill` command.


------------------------------------------------------------------------------
                                                                    *:RInsert*
                                                                    *:RFormat*
The command `:RInsert` <cmd> inserts one or more lines with the output of the
R command sent to R. By using this command we can avoid the need of copying
and pasting the output of R from its console to Neovim. For example, to insert
the output of `dput(levels(var))`, where `var` is a factor vector, we could do
in Neovim:
>vim
   :RInsert dput(levels(var))
<
The command `:RFormat` calls the function `style_text()` (if the package
`styler` is installed) to format the selected lines. If no text is selected,
either `style_file()` is called to format the entire buffer. The command only
works if R is running. The value of 'shiftwidth' is passed as `indent_by`.


------------------------------------------------------------------------------
4.2. Editing Rnoweb files

See |rnoweb-chunks| to know how to properly include chunk options.

In Rnoweb files (.Rnw), when the cursor is over the `@` character, which
finishes an R chunk, the command to send a line to R Console will make cursor
to jump to the next chunk. While editing Rnoweb files, the following commands
are available in Normal mode:

   [count]<LocalLeader>gn : go to the next chunk of R code
   [count]<LocalLeader>gN : go to the previous chunk of R code

You can also press <LocalLeader>gt to go the corresponding line in the
generated .tex file (if SyncTeX is enabled).

The commands <LocalLeader>cc and cd send the current chunk of R code
to R Console. The command <LocalLeader>ch sends the R code from the first
chunk up to the current line.

The commands <LocalLeader>kn builds the .tex file from Rnoweb using the knitr
package and <LocalLeader>kp compiles the PDF; for Sweave, the commands are,
respectively <LocalLeader>sw and <LocalLeader>sp. You can jump from the Rnoweb
file to the PDF (SyncTeX forward search) with the command <LocalLeader>gp. The
command to jump from a specific location in the PDF to the corresponding line
in the Rnoweb (backward search) is specific to each PDF viewer:

   Zathura: <C-LeftMouse>
   Skim:    <S-Cmd-Click>
   Sumatra: <Double-click>

In any case, the PDF viewer must be started by the R.nvim plugin. See
|R.nvim-SyncTeX| for details.


------------------------------------------------------------------------------
4.3. Auto-completion

If `cmp-r` (a source for `nvim-cmp`) is installed, Neovim can
automatically complete the names of R objects as you type them.

R.nvim does not complete the names of all functions of all installed packages
(see |start_libs|); only of loaded libraries.

For both `library()` and `require()`, when completing the first argument, the
popup list shows the names of installed packages.


------------------------------------------------------------------------------
4.4. The Object Browser

You have to use <LocalLeader>ro to either open or close the Object Browser on
the same tab page. If it is already open on another tab page, it will be
closed there and opened again in the current one. The Object Browser has two
views: .GlobalEnv and Libraries. If you press <Enter> on the first line of the
Object Browser it will toggle the view between the objects in .GlobalEnv and
the currently loaded libraries.

In the .GlobalEnv view, if a data.frame column has the attribute "label", it
will also be displayed. For instance, the code below would make the Object
Browser display the variable labels of an imported SPSS dataset:
>r
   library("haven")
   d <- read_spss("/path/to/spss/dataset.sav")
<
In the Object Browser window, while in Normal mode, you can either press
<Enter> or double click over a data.frame or list to show/hide its elements.
If you are running R in an environment where the string UTF-8 is part of
either LC_MESSAGES or LC_ALL variables, Unicode line drawing characters will
be used to draw lines in the Object Browser. This is the case of most Linux
distributions.

In the Libraries view, you can either double click or press <Enter> on a
library name to see its objects. In the Object Browser, the libraries have the
color defined by the PreProc highlighting group. The other objects have
their colors defined by the return value of some R functions. Each line in the
table below shows a highlighting group and the corresponding type of R object:

         PreProc        libraries
         Include        environment
         Number                numeric
         String                character
         Special        factor
         Boolean        logical
         Type                data.frame
         StorageClass        list
         Structure        s4
         Function        function
         Statement        control flow (for, while, break, etc)
         Comment        promise (lazy load object)

One limitation of the Object Browser is that objects made available by the
command `data()` are only links to the actual objects (promises of lazily
loading the object when needed) and their real classes are not recognized in
the GlobalEnv view. The same problem happens when the `knitr` option
`cache.lazy=TRUE`. However, if you press <Enter> over the name of the object
in the Object Browser, it will be actually loaded by the command (ran in the
background):
>r
   obj <- obj
<
Notes:

  - If either the Object Browser is open or cmp-r is installed, the
    list of .GlobalEnv objects will be automatically updated by R after each
    successful command evaluation. This may slowdown R if its workspace has
    too many objects, data.frames with too many columns or lists with too many
    elements.

  - Names of objects are stupidly truncated if they occupy more than 62 bytes.
    This means that Unicode sequences might be split and become invalid.

  - Active bindings are not included in the list of objects for auto
    completion. Also, they are not included in the Object Browser.


------------------------------------------------------------------------------
4.5. Build a tags file to jump to function definitions            *RBuildTags*

Neovim can jump to functions defined in other files if you press CTRL-] over
the name of a function, but it needs a tags file to be able to find the
function definition (see |tags-and-searches|). The command `:RBuildTags` calls
the R functions `rtags()` and `etags2ctags` to build the tags file for the R
scripts in the current directory.

As an alternative, R's `languageserver` can also jump to function
definitions.


------------------------------------------------------------------------------
4.6. Syntax highlight of .Rout files

You can set both foreground and background colors of R output in your
`init.lua`. The example below is for an interface of Neovim with
'termguicolors' (see |true-color|):
>lua
   if vim.o.termguicolors then
     vim.g.rout_color_input    = "guifg=#9e9e9e"
     vim.g.rout_color_normal   = "guifg=#ff5f00"
     vim.g.rout_color_number   = "guifg=#ffaf00"
     vim.g.rout_color_integer  = "guifg=#feaf00"
     vim.g.rout_color_float    = "guifg=#fdaf00"
     vim.g.rout_color_complex  = "guifg=#fcaf00"
     vim.g.rout_color_negnum   = "guifg=#d7afff"
     vim.g.rout_color_negfloat = "guifg=#d6afff"
     vim.g.rout_color_date     = "guifg=#00d7af"
     vim.g.rout_color_true     = "guifg=#5dd685"
     vim.g.rout_color_false    = "guifg=#ff5d5e"
     vim.g.rout_color_inf      = "guifg=#10aed7"
     vim.g.rout_color_constant = "guifg=#5fafcf"
     vim.g.rout_color_string   = "guifg=#5fd7af"
     vim.g.rout_color_error    = "guifg=#ffffff guibg=#c40000"
     vim.g.rout_color_warn     = "guifg=#d00000"
     vim.g.rout_color_index    = "guifg=#d0d080"
   end
<
If you prefer that R output is highlighted using your current `colorscheme`,
put in your `init.lua`:
>lua
   vim.g.rout_follow_colorscheme = true
<

------------------------------------------------------------------------------
4.7. Debugging R functions (Unix only)                     *debug-R-functions*

`R.nvim` has limited debugging facilities available on Unix systems (not
available on Windows). To debug a function with R.nvim you have to do the
following:

   1. Load the functions into R either by a) sourcing the R script where the
      function is with the `source()` function of the `base` package or b)
      loading all desired functions with `devtools::load_all(<relevant path>)`.

   2. Flag a function or line of code within a function to use the debugger.
      This can be done by using the `debug` functions or setting a breakpoint
      with the `browser` functions from the `base` package. To use `debug`,
      in the R Console, run either `debug(funcname)` or `debugonce(funcname)`
      where `funcname` is the name of the function (not quoted). R.nvim will
      send this command to R Console if you press <LocalLeader>bg in Normal
      mode with the cursor over the function name. Use `<LocalLeader>ud` with the cursor on a function to undebug it. An example of using
      `browser` is shown later in the documentation.

   3. Call the function.

See `:RHelp browser` for available commands in debugging mode.

For example, if you have a file named `my_function.R` with the following
contents:
>r
   add.one <- function(x){
       y <- x + 1
       print(y)
       return(invisible(NULL))
   }
<
You could debug the `add.one()` function from another script such as:
>r
   source("path/to/my_function.R")
   debug(add.one)
   add.one(7)
<
If you do not want to start debugging the function from its first line,
instead of calling `debug(funcname)` before calling the function, you should
add the line `browser()` to the function at the line where the debugging
session should start. Example:
>r
   add.one <- function(x){
       y <- x + 1
       browser()
       print(y)
       return(invisible(NULL))
   }
<
If you want a conditional breakpoint, you should call the `browser()` command
only if a condition is satisfied. Example:
>r
   add.one <- function(x){
       y <- x + 1
       if(x > 9)
           browser()
       print(y)
       return(invisible(NULL))
   }
<
One limitation is that R.nvim also does not help you setting breakpoints.
You have to set them manually as explained above.

Another limitation of R.nvim is that it might be unable to jump to the line in
the source code that is being evaluated if either you have sent the function
directly to the R Console or the function has been sent by the `knitr`
package, without calling the function `source()`. In either case, R.nvim will
try to find the pattern `funcname <- function(` in the buffer being edited. If
the pattern is found, the cursor will jump to its position.

The highlighting group used to highlight the line being debugged is the
QuickFixLine (see |hl-QuickFixLine|). Its foreground and background colors are
defined by your colorscheme.


------------------------------------------------------------------------------
4.8 roxygen2 support                                         *R.nvim-roxygen2*

R.nvim supports the insertion of roxygen2 skeletons in R scripts. To insert a
new roxygen2 block, you can use the `:Roxygenize` command while the cursor is
inside a function definition. If a block of roxygen2 is already present, no
modification will be made.


==============================================================================
5. Known bugs and workarounds                              *R.nvim-known-bugs*

Known bugs that will not be fixed are listed in this section. Some of them can
not be fixed because they depend on missing features in either R or Neovim;
others would be very time consuming to fix without breaking anything.


------------------------------------------------------------------------------
5.1. R must be started by R.nvim

The communication between Neovim and R will work only if R was started by the
running Neovim instance through the <LocalLeader>rf command. If you use R.nvim
to start R in an external terminal and, then close Neovim and open it again,
there will be no communication between R and the new Neovim instance.

Please see the explanation on the communication between Neovim and R at the
end of

   https://github.com/R-nvim/R.nvim/blob/master/README.md


------------------------------------------------------------------------------
5.2. Cannot raise window (web browser or PDF viewer)

When you generate an HTML or PDF document from a Quarto, Rmd, or Rnoweb
document, R.nvim can raise (focus) the web browser or PDF viewer if you are
using Xorg or Sway (both on Linux). The necessary code was not written yet for
other systems (macOS, Windows, and most Wayland compositors on Linux). Please,
see the function `utils.get_focused_win_info()` if you want to fix the issue
on your system.


------------------------------------------------------------------------------
5.3. Object Browser and auto-completion limitations

New lines in list names (which includes column names in data frames and
matrices) are replaced with blank spaces in the data used by `cmp-r` and the
Object Browser.

Objects from environments accessed with the `browser()` function are not
listed in the Object Browser or during auto-completion with `cmp-r`.


------------------------------------------------------------------------------
5.4 R code block not recognized within HTML tags

An R code block in a Markdown document is not recognized when within an HTML
tag unless there is an extra empty line between the tag and the beginning of
the block. So, for example, instead of:
>
 <div>
 ```{r}
 runif(3) # not recognized as R code
 ```
 </div>
<
We need:
>
 <div>

 ```{r}
 runif(3) # recognized as R code
 ```
 </div>
<
This happens because tree-sitter-markdown follows the CommonMark
specification, which treats anything that follows an HTML tag as verbatim
until an empty line is found.


------------------------------------------------------------------------------
5.5 Old style chunks not properly recognized in Rnoweb         *rnoweb-chunks*

Chunks of R code with old style headers are not correctly recognized by
tree-sitter and, consequently, it's not properly highlighted and sent to the
R Console. So, instead of:
>
   <<example, echo=TRUE, results="asis">>=
   x <- 1
   print(x)
   @
<
You should write:
>
   <<example>>=
   #| echo: true
   #| results: "asis"

   x <- 1
   print(x)
   @
<

------------------------------------------------------------------------------
5.6 You can't put `syntax enable` in your `init.vim` (macOS only)

It seems that if you put the command `syntax enable` in your `init.vim` on
macOS, file type plugins are immediately sourced. Consequently, all R.nvim
variables will be used at their default values. The workaround is do not
include the superfluous command `syntax enable` in the `init.vim`. For
details, please, access:

   https://github.com/jalvesaq/Nvim-R/issues/668


------------------------------------------------------------------------------
5.7. Windows bugs and limitations

------------------------------
Wrong message that "R is busy"

On Windows, when code is sent from Neovim to R Console, the nvimcom library
sets the value of the internal variable `r_is_busy` to 1. The value is set
back to 0 when any code is successfully evaluated. If you send invalid code to
R, there will be no successful evaluation of code and, thus, the value of
`r_is_busy` will remain set to 1. Then, if you try to update the object
browser, see the R documentation for any function, or do other tasks that
require hidden evaluation of code by R, the nvimcom library will refuse to
do the tasks to avoid any risk of corrupting R's memory. It will tell Neovim
that "R is busy" and Neovim will display this message. Everything should work
as expected again after any valid code is executed in the R Console.


--------------------------------------
Error if there is no package installed

On Windows, Neovim may fail to recognize that a directory is not writable, and
this is required by R.nvim to detect if it is necessary to create the
directory defined by `$R_LIBS_USER` environment variable. Consequently, R.nvim
does no try to create the directory and nvimcom installation fails. This
problem will happen if you have just installed or upgraded R. The workaround
is to manually open R and install any package with the `install.packages()`
command before using R.nvim.


--------------------------------------
~/.Rprofile should not output anything

The compilation of `nvimcom` during R startup will fail on Windows if your
`~/.Rprofile` outputs anything. Example of how to replicate the bug:
>r
   print("This message will break compilation by gcc!")
<

-----------------------------------------
Send commands to Radian doesn't work well

If you use `radian` as |R_app|, multiple lines will not be correctly
interpreted because `bracketed_paste` is not recognized by terminals on
Windows.


==============================================================================
6. Options                                                    *R.nvim-options*

The complete list of options and their defined values can be seen with the
command:
>vim
   :RConfigShow
<
You may close the window opened by `:RConfigShow` by simply pressing `q`.

|auto_quit|	    Quits R when quitting Neovim
|auto_start|          Start R automatically
|objbr_auto_start|    Start the Object Browser automatically
|built-in-terminal|   Options to control Neovim's built-in terminal
|external_term|       Command to run R in an external terminal emulator
|silent_term|         Do not show terminal errors
|set_home_env|        Set the value of $HOME for R (Windows only)
|save_win_pos|        Save position of Rgui window (Windows only)
|arrange_windows|     Restore position of R window (Windows only)
|pipe_version|        Either "native"/"|>" or "magrittr"/"%>%"
|rproj_prioritise|    Use .Rproj file to override options
|objbr_place|         Placement of Object Browser
|objbr_w|             Initial width of Object Browser window
|objbr_h|             Initial height of Object Browser window
|objbr_opendf|        Display data.frames open in the Object Browser
|objbr_openlist|      Display lists open in the Object Browser
|objbr_allnames|      Display hidden objects in the Object Browser
|objbr_mappings|      Add custom keymap to the Object Browser
|objbr_placeholder|   Define the string to substitute for with objects
|compl_data|          Limits to completion data (avoid R slowdown)
|nvimpager|           Use Neovim to see R documentation
|open_example|        Use Neovim to display R examples
|R_path|              Directory where R is
|R_app|, |R_cmd|        Names of R applications
|R_args|              Arguments to pass to R
|start_libs|          Objects for auto completion
|Rout_more_colors|    More syntax highlighting in R output
|routnotab|           Show output of R CMD BATCH in new window
|config_tmux|         Don't use a specially built Tmux config file
|rconsole_height|     Number of lines of R Console
|rconsole_width|      Number of columns of R Console
|register_treesitter| Register treesitter parsers for quarto and rmd files
|min_editor_width|    Minimum number of columns of editor after R start
|RStudio_cmd|         Run RStudio instead of R.
|listmethods|         Do `nvim.list.args()` instead of `args()`
|specialplot|         Do `nvim.plot()` instead of `plot()`
|paragraph_begin|     Send paragraph from its beginning
|parenblock|          Send lines until closing parenthesis
|bracketed_paste|     Bracket R code in special escape sequences
|clear_console|       Send <C-L> to clear R's console
|source_args|         Arguments to R `source()` function
|max_paste_lines|     Maximum number of lines to be pasted into R Console
|latexcmd|            Command to run on .tex files
|texerr|              Show a summary of LaTeX errors after compilation
|sweaveargs|          Arguments do `Sweave()`
|rmd_environment|     Environment in which to save evaluated rmd code
|rmarkdown_args|      Further options to be passed to `rmarkdown::render()`
|quarto_render_args|  Options to be passed to `quarto::quarto_render()`
|quarto_preview_args| Options to be passed to `quarto::quarto_preview()`
|clear_line|          Clear R Console line before sending a command
|editing_mode|        The mode defined in your `~/.inputrc`
|pdfviewer|           PDF application used to open PDF documents
|open_pdf|            Open PDF after processing Rmd, Quarto or Rnoweb file
|open_html|           Open HTML after processing Rmd or Quarto
|insert_mode_cmds|    Allow R commands in insert mode
|rmhidden|            Remove hidden objects from R workspace
|set_params|          Control setting `params` in `.GlobalEnv`
|wait|                Time to wait for nvimcom loading
|wait_reply|          Time to wait for R reply
|setwd|               Directory where to start R
|hook|                Lua functions to call after certain events
|user_maps_only|      Only user specified key bindings
|disable_cmds|        List of commands to be disabled
|tmpdir|              Where temporary files are created
|compldir|            Where lists for auto completion are stored
|remote_compldir|     Mount point of remote cache directory
|view_df|             Options for visualizing a data.frame or matrix
|R.nvim-SyncTeX|      Options for SyncTeX
|debug|               Support for debugging functions


------------------------------------------------------------------------------
6.1. Automatic start: R and Object Browser                        *auto_start*
                                                            *objbr_auto_start*

By default, you have to start R manually with the command <LocalLeader>rf.
If you want that R starts automatically when you load an R script while
starting Neovim, put in your config:
>lua
   auto_start = "on startup"
<
If you want that R starts automatically when you start editing an R script
even if Neovim is already started, put in your config:
>lua
   auto_start = "always"
<
The default value of `auto_start` is "no".
See also: |hook|.

If you want to always start the Object Browser immediately after starting R,
put in your config:
>lua
   objbr_auto_start = true
<
See also: |hook|.


------------------------------------------------------------------------------
6.2. R in Neovim built-in terminal                       *R-built-in-terminal*
                                                                    *esc_term*
By default, R runs in a Neovim buffer created with the command |:term|,
and the <Esc> key is mapped to stop the Terminal mode and go to Normal mode.
In Terminal mode, What you type is passed directly to R while in Normal mode
Vim's navigation commands work as usual (see |motion.txt|).

If you need the <Esc> key in R, for example if you want to use `vi`, `vim` or
`nvim` within R Console, put in your config:
>lua
   esc_term = false
<
Then, you will have to press the default <C-\><C-n> to go from Terminal to
Normal mode.

R.nvim sets the option "editor" to a function that makes the object to be
edited in a new tab when `esc_term` = `true` (the default value).
                                                               *close_term*
Neovim does not close its built-in terminal emulator when the application
running in it quits, but R.nvim does close it for you. If you rather prefer
that the terminal remains open after R quitting, put in your config:
>lua
   close_term = false
<
Neovim stops automatically scrolling the R Console if you move the cursor to
any line that is not the last one. This emulates the behavior of other
terminal emulator, but considering that (1) R only outputs something after we
send a command to it, and (2) when we send a command to R, we want to see its
output, R.nvim will move the cursor to the last line of R Console before
sending a command to it, forcing the auto scrolling of the terminal. You can
disable this feature with the option:
>lua
   auto_scroll = false
<
                                                                   *hl_term*
You may either use the package colorout (Unix only) to colorize R output or
let Neovim highlight the terminal contents as it was a .Rout file type. Two
advantages of colorout are the possibility of highlighting numbers close to
zero in a different color and the distinction between stdout and stderr. The
value of `hl_term` (`false` or `true`) determines whether Neovim should syntax
highlight the R output, and its default value will be set to `false` if the
package colorout is loaded. If you prefer do not rely on the auto detection
of colorout, you should set the value of `hl_term` in your config. Example:
>lua
   hl_term = false
<                                                                    *OutDec*
Right after starting R, R.nvim will try to detect if either the value of R's
`OutDec` option is `","` or the current R script sets the `OutDec` option. If
you are using Neovim to syntax highlight R's output and it is not correctly
detecting R's `OutDec` option, then, to get numbers correctly recognized, you
should put in your config:
>lua
   OutDec = ","
<                                                                  *setwidth*
On Unix systems, BEFORE sending a command to R Console, if the terminal width
has changed, Neovim will send to nvimcom the command `options(width=X)`,
where X is the new terminal width. You can set the value of `setwidth` to 0 to
avoid the width being set. Example:
>lua
   setwidth = 0
<
On Windows, the command is sent to R Console because it would crash R if sent
through nvimcom.

If you have the option 'number' set in your config, R.nvim will calculate the
number of columns available for R as the window width - 6. If you want a
different adjustment, you should set `setwidth` as a negative value between
-1 and -16. Example:
>lua
   setwidth = -7
<
You can also set the value of `setwidth` to `2`. In this case, nvimcom will
check the value of the environment variable `COLUMNS` AFTER each command is
executed and if the environment variable exists, R's width option will be set
accordingly. This is the most precise way of setting the option "width", but
it has the disadvantage of setting it only after the command is executed. That
is, the width will be outdated for the first command executed after a change
in the number of columns of the R Console window.

                                                               *buffer_opts*
R.nvim sets the options 'winfixwidth' and 'winfixheight' in the window where R
runs. This prevents the window of being automatically resized in some
circumstances. It also sets the option 'nobuflisted'. You can set the value of
`buffer_opts` to define what options should be set in the R Console buffer.
It is a list of Vim options separated by spaces. Example with its default
value:
>lua
   buffer_opts = "winfixwidth winfixheight nobuflisted"
<
If you do not want to run R in Neovim's built-in terminal emulator, you
have to install Tmux >= 3.0, and then put in your config:
>lua
   external_term = "default"
<
Then, R will start in an external terminal emulator (useful if you use two
monitors and want Neovim and R separate from each other), and Tmux will be
used to send commands from Neovim to R.


------------------------------------------------------------------------------
6.3. Terminal emulator (Linux/Unix only)                       *external_term*
                                                                 *silent_term*

Note: The options of this section are ignored on macOS, where the command
`open` is called to run the default application used to run shell scripts.

R will run in Neovim's built-in terminal emulator, unless you set the value of
`external_term`, which can be `""` (use Neovim's built-in terminal),
`"default"` (automatically choose a pre-defined terminal), the name of the
terminal emulator or the complete command to run the terminal emulator. On
Windows, if the value of `external_term` is `"default"`, R.nvim will run
`Rgui.exe`, and not really a terminal emulator.

On Linux, a command for running the terminal is predefined for the following
options:

    1. foot
    2. kitty
    3. gnome-terminal
    4. konsole
    5. xfce4-terminal
    6. alacritty
    7. xterm


If the value of `external_term` is `"default"`, the plugin runs the first terminal
emulator that it finds from the above list. If your favorite terminal emulator
is not selected, you may define it in your config. Below are some examples of
how to set the value of `external_term`:
>lua
   external_term = "default" -- Run R in an external terminal (or Rgui.exe)
   external_term = "konsole" -- Run R in konsole
<
If `external_term` is just the name of one of the above terminal emulators,
R.nvim will start it with the arguments for setting the title and the
working directory. If you need more than this, you may define in your config
variable `external_term` as the complete command to run the terminal.
Examples (see also https://github.com/R-nvim/R.nvim/wiki/External-Terminals):
>lua
   external_term = "xterm -title R -e"
   external_term = "tilix -a session-add-right -e"
   external_term = "xfce4-terminal --icon=/path/to/icons/R.png --title=R -x"
   external_term = "foot -a R -T R --login-shell --log-level error"
<
Please, look at the manual of your terminal emulator to know how to call it.
The last argument must be the one which precedes the command to be executed.

Although the option is intended to allow running R in an external terminal
emulator, if you are running Neovim within Tmux, it can also be used to run R
in a Tmux split panel. Examples:
>lua
   external_term = "tmux split-window -vf"
   external_term = "tmux split-window -h -l 80"
<
The terminal error messages, if any, are shown as warning messages, unless you
put in your config:
>lua
   silent_term = true
<
								   *auto_quit*
When Neovim is closed, the R connection with Neovim is closed and cannot be
reestablished. Thus, unless you usually keep working on the R Console after
quitting Neovim, you will prefer that R quits automatically when you leave
Neovim. In this case, you have to put in your config:
>lua
   auto_quit = true
<
The default value of `auto_quit` is `true` if R is running in a Neovim's
built-in terminal emulator and `false` otherwise.


------------------------------------------------------------------------------
6.4. Windows specific options                                *save_win_pos*
                                                             *arrange_windows*
                                                             *set_home_env*
                                                             *Rtools-path*
If R cannot find either `make` or `gcc` while trying to compile nvimcom, you
should add their directories to the beginning of the `PATH` environment
variable in your |init.lua|. Example:
>lua
   vim.env.PATH = "C:\\rtools40\\mingw64\\bin;C:\\rtools40\\usr\\bin;" .. $PATH
<
By default, R.nvim will save the positions of R Console and Neovim windows
when you quit R with the <LocalLeader>rq command, and it will restore the
positions of the windows when you start R. If you do not like this behavior,
you can put in your config:
>lua
   save_win_pos = false
   arrange_windows = false
<
If you want Rgui window always in a specific arrangement, regardless of
its state when you have quit R for the last time, you should arrange it
in the way you want, quit R, change in your config only the value of
`save_win_pos` and, finally, quit Neovim.

The plugin sets `$HOME` as the Windows register value for "Personal" "Shell
Folders" which is the same value set by R. However, if you have set `$HOME`
yourself with the intention of changing the default value of `$HOME` assumed
by R, you will want to put in your config:
>lua
   set_home_env = false
<

------------------------------------------------------------------------------
6.5. Insertion of pipe operator                                 *pipe_version*

There is a keybinding for inserting the pipe operator (`|>`) which defaults to
`<LocalLeader>,`. See |R.nvim-key-bindings| to know how to customize or
disable the key binding.

R.nvim is aware of `.Rproj` files (the project-level configuration files used
by RStudio). This may, for example, change whether `<Plug>RInsertPipe` inserts
`|>` or `%>%` for a particular project. See the option |rproj_prioritise| for
a full list of the behaviours which may be affected by `.Rproj` files, or to
change whether they should affect things at all.


------------------------------------------------------------------------------
6.6. Object Browser and completion options                    *objbr_w*
                                                              *objbr_h*
                                                              *objbr_place*
                                                              *objbr_opendf*
                                                              *objbr_openlist*
                                                              *objbr_allnames*
                                                              *compl_data*
                                                              *objbr_mappings*
                                                              *objbr_placeholder*
By default, the Object Browser will be created at the right of the script
window, and with 40 columns. Valid values for the Object Browser placement are
the combination of either "script" or "console" and "right", "left", "above",
"below", separated by a comma. You can also simply choose "RIGHT", "LEFT",
"TOP" or "BOTTOM" to start the Object Browser as far as possible to the
indicated direction. Examples:
>lua
   objbr_place = "script,right"
   objbr_place = "console,left"
   objbr_place = "LEFT"
   objbr_place = "RIGHT"
<
The minimum width of the Object Browser window is 9 columns. You can change
the object browser's default width by setting the value of |objbr_w| in your
config, as below:
>lua
   objbr_w = 30
<
If the Object Browser is being created below or at the top of the existing
window, it will be 10 lines high, unless you set its height in your config:
>lua
   objbr_h = 20
<
Below is an example of setup of some other options in the config that
control the behavior of the Object Browser:
>lua
   objbr_opendf = true     -- Show data.frames elements
   objbr_openlist = false  -- Show lists elements
   objbr_allnames = false  -- Show hidden objects
<
Objects whose names start with a "." are hidden by default. If you want them
displayed in the Object Browser, set the value of `objbr_allnames` to `true`.

When a `data.frame` appears in the Object Browser for the first time, its
elements are immediately displayed, but the elements of a `list` are displayed
only if it is explicitly opened. The options `objbr_opendf` and
`objbr_openlist` control the initial status (either opened or closed) of,
respectively, `data.frames` and `lists`. The options are ignored for
`data.frames` and `lists` of libraries which are always started closed.

When building the list of objects for auto completion and for the Object
Browser, `nvimcom` inspects lists only as deep as 3 levels. When the time to
build the completion data is higher than 100 ms `nvimcom` decreases the number
of levels it inspects in lists. Even if `nvimcom` can build the completion
data in less than 100 ms, it also decrease the maximum level of list
inspection if the resulting completion data is bigger than 1,000,000 bytes
because big data may take a noticeably long time to be transmitted through the
TCP connection. When `nvimcom` automatically decreases the depth of list
inspection, if `nvimcom.verbose` is > 1, it outputs information like the
following on R Console:

   nvimcom:
       Time to build list of objects: 7.582 ms (max_time = 100 ms)
       List size: 1611734 bytes (max_size = 1000000 bytes)
       New max_depth: 9

The value of `max_depth` will automatically increase if necessary when you try
to open a list in the Object Browser. However, it will not increase if you try
to complete deep elements in the list.

You can set different values for `time_limit`, `size_limit`, and `max_depth`
in the Lua table `compl_data` in your `R.nvim` config. Below are the default
values:
>lua
    compl_data = {
        max_depth = 3,
        max_size = 1000000,
        max_time = 100,
    },
<
You should increase the value of `max_depth` if you want to complete or see in
the Object Browser more than 3 list levels. You should increase either
`max_size` or `max_time` if `nvimcom` needs more space or more time to build
the completion data with the desired list depth. You should decrease the
values if you notice any delay when R is running commands. In this case,
please, put `options(nvimcom.verbose = 1)` in your `~/.Rprofile` and use the
information output by `nvimcom` to decide what parameter to change.

It is possible to add a custom keymap through `objbr_mappings` table. The
keymap defined in this table will be available in the object browser only.
Using this method, you can set keymaps that run Lua functions or R code. The
following paragraphs documents how this feature works.

In `objbr_mappings`, you can bind R functions (without parentheses) to keys.
In the following example, pressing `l` in the object browser will run
`length({object})` in the current R session, where `{object}` is the object
under the cursor in the object browser.
>lua
      objbr_mappings = {
        c = 'class',
        l = 'length',
        n = 'names',
        s = 'summary',
        t = 'table',
      },
<
It is also possible to use R namespacing to call R code not defined in the
current R session. The following example run `glimpse` function from the R
package `dplyr` on `object` (i.e., simply sends `dplyr::glimpse({object})`) to
the current session.
>lua
      objbr_mappings = {
        g = 'dplyr::glimpse',
      },
<
You can also explicitly use `{object}` notation in you bindings. This allows
you to bind more complicated R expressions.
>lua
      objbr_mappings = {
        -- Similar to the previous.
        t = 'table({objects})',
        g = 'dplyr::glimpse({object})',
        -- using {object}
        sna = 'sum(is.na({object}))', -- count NAs of a vector.
      },
<
R code can potentially include any sequence of character, and in the edge
case, the R code you define in `objbr_mappings` may itself include the pattern
`{object}`. In this case, R.nvim will falsely replace legitimate `{object}`
patterns in R expressions with the name of the object under cursor. In that
case (or if `{object}` feels too much to type), you may want to use a
pattern other than `{object}` to refer to objects under cursor in the object
browser. Here you should define `objbr_placeholder` in your `config` table.
>lua
      objbr_mappings = {
        t = 'table',
        g = 'dplyr::glimpse',
        sna = 'sum(is.na(@@))',
      },
      objbr_placeholder = '@@'
<
One might need to use special keys (e.g., <localleader>, <CR>, etc) when defining a
keymap. Lua allows the use *bracket notation* to use non-alphanumeric
characters in table keys.
>lua
      objbr_mappings = {
        ['<localleader>gg'] = 'head({object}, 30)',
      },
<
You can also bind keys to Lua functions. For example, the following example binds
`e` to an anonymous function that fetches the definition of an R function
under the cursor and opens it in a new vim buffer. The code also binds `v` in the
object browser to toggle between the two view (i.e., `.Globalenv` and `Libraries`).
>lua
      objbr_mappings = {
        ['<localleader>gg'] = 'head',
        e = function()
          local browser = require 'r.browser'
          local config = require('r.config').get_config()
          local lnum = vim.api.nvim_win_get_cursor(0)[1]
          local curline = vim.fn.getline(lnum)
          local object_name = browser.get_name(lnum, curline)
          if object_name == '' then
            require('r').warn 'No object selected.'
            return
          end

          local temp_file = config.localtmpdir .. '/function_def_' .. vim.env.RNVIM_ID .. '.R'

          -- Send R command to write the function definition to a temp file
          local cmd = string.format('writeLines(deparse(%s), "%s")', object_name, temp_file)
          require('r.send').cmd(cmd)

          -- Wait for R to execute the command and write the file
          vim.defer_fn(function()
            local output = vim.fn.readfile(temp_file)
            if not output or #output == 0 then
              require('r').warn 'Could not retrieve function definition.'
              return
            end

            -- Open a new split window and display the function definition
            vim.cmd 'split'
            vim.cmd 'enew'
            vim.bo.filetype = 'r' -- Set filetype to R
            vim.api.nvim_buf_set_lines(0, 0, -1, false, output)

          end, 100)
        end,
        t = 'table',
        v = function()
          require('r.browser').toggle_view()
        end,
      },
<

------------------------------------------------------------------------------
6.7. Neovim as pager for R                                      *open_example*
                                                                *nvimpager*

If you do not want to see R examples in a Neovim buffer, put in your config:
>lua
   open_example = false
<
If you do not want to see R documentation in a Neovim buffer, put in your
config:
>lua
   nvimpager = "no"
<
If you want to see R documentation in Neovim, but are not satisfied with the
way it works, please, read the subsection 6.7.2 below.

The plugin key bindings will remain active in the documentation buffer, and,
thus, you will be able to send commands to R as you do while editing an R
script. You can, for example, use <LocalLeader>rh to jump to another R help
document.

The valid values of `nvimpager` are:

   "tab"       : Show the help document in a new tab. If there is already a
                 tab with an R help document tab, use it.
                 This is the default if `external_term` is not `""`.
   "split_h"   : Split the window horizontally, as `:help` does. That is,
                 display R documentation above the editor window or at the
                 very top of the screen.
   "split_v"   : Split the window vertically. Display R documentation to
                 the right of the editor window.
   "float"     : Not implemented yet.
   "no"        : Do not show R documentation in Neovim.


------------------------------------------------------------------------------
6.8. R path and application names                                     *R_path*
                                                                      *R_app*
                                                                      *R_cmd*

Neovim will run the first R executable in the path. You can set an alternative
path to R in your config as in the examples:
>lua
   R_path = "/path/to/my/preferred/R/version/bin"
   R_path = "C:\\Program Files\\R\\R-4.3.3\\bin\\x64"
<
On Windows, Neovim will try to find the R install path in the Windows Registry.

The `R_path` variable can also be prefixed to the `PATH` environment variable.
So, it can include more than one directory separated by a `;` on Windows or a
`:` on other systems. This is specially important to include the path to
RTools `bin` directories on Windows. Example:
>lua
   R_path = "C:\\rtools40\\mingw64\\bin;C:\\rtools40\\usr\\bin;C:\\Program Files\\R\\R-4.3.3\\bin\\x64"
<
By default `R_cmd` is `"R"` (the same as `R_app`) and will be used to run some
scripts in the background, such as:
>
   R CMD build nvimcom
   R CMD install nvimcom
   R CMD BATCH current_script.R
<
If it is necessary to call a different application to run the above commands
in your system, you should set the value of `R_cmd` in your config.

By default the value of `R_app` is `"R"` on Unix systems (such as Linux and
macOS). On Windows, it is `Rterm.exe` if R is going to run in a Neovim
buffer and `"Rgui.exe"` otherwise. R.nvim cannot send messages to `Rterm.exe`
in an external `cmd` window. If your R binary has a different name (for
example, if it is called by a custom script), you should set the value of
`R_app` in your config (and, perhaps, `R_cmd` too). Example:
>lua
   R_app = "radian"
   R_cmd = "R"
<

------------------------------------------------------------------------------
6.9. Arguments to R                                                   *R_args*

Set this option in your config if you want to pass command line arguments to
R at the startup. The value of this variable must be a `string[]`. Example:
>lua
   R_args = { "--no-save", "--quiet" }
<
On Linux, there is no default value for |R_args|. On Windows, the default
value is `{"--sdi"}`, but you may change it to `{"--mdi"}` if you do not like
the SDI style of the graphical user interface.


------------------------------------------------------------------------------
6.10. Auto-completion                                             *start_libs*

There are two ways of getting automatic completion of R objects names while
you type: using R.nvim's built-in completion system (as a source for
`nvim-cmp`) and using a language server. See:

   https://github.com/jalvesaq/cmp-r
   https://github.com/REditorSupport/languageserver

The advantage of R.nvim's built-in system is the ability to complete objects
of the R's workspace (`.GlobalEnv`), including column names of data.frames.

Note: If you are using the `languageserver` package, you should disable its
auto completion feature in your `~/.Rprofile` to get completions from
`cmp-r`:
>r
   options(languageserver.server_capabilities =
           list(completionProvider = FALSE,
                completionItemResolve = FALSE))
<
If you prefer to get completions from the language server, `cmp-r` should
not be installed.

The list of objects for auto completion is built dynamically as the libraries
are loaded by R. If R is running, only the names of objects in .GlobalEnv and
in loaded libraries are completed. If R is not running, only objects of
libraries listed in `start_libs` and as the first argument of either
`library()` and `require()` commands in the current buffer will have their
names completed. However, you can set the value of `start_libs` if you want
that objects of specific packages are available for auto completion even if R
is not running yet. Below is the default value of `start_libs`:
>lua
   start_libs = "base,stats,graphics,grDevices,utils,methods"
<
------------------------------------------------------------------------------
6.11. Rout highlighting                                     *Rout_more_colors*

By default, the R commands in .Rout files are highlighted with the color of
comments, and only the output of commands has some of its elements highlighted
(numbers, strings, index of vectors, warnings and errors).

If you prefer that R commands in the R output are highlighted as they are in R
scripts, put the following in your config:
>lua
   Rout_more_colors = true
<
When syntax highlighting .Rout files, R.nvim considers "> " as the prompt
string and "+ " as the continuation string. If you have defined different
prompt and continuation strings in your `~/.Rprofile`, R.nvim will try to get
them from R, but if they include special characters, you may have to define
them in your |init.lua| too to avoid errors and get them properly highlighted.
For example, if you have in your `~/.Rprofile`
>r
   options(prompt = "\x1b[34m»\x1b[0m ")
<
you should put in your config:
>lua
   R_prompt_str = "»"
<

------------------------------------------------------------------------------
6.12. How to automatically open the .Rout file                   *routnotab*

After the command <LocalLeader>ao, Neovim will save the current buffer if it
has any pending changes, run `R CMD BATCH --no-restore --no-save` on the
current file and show the resulting .Rout file in a new tab. If you prefer
that the file is open in a new split window, put in your config:
>lua
   routnotab = true
<

------------------------------------------------------------------------------
6.13. Tmux configuration (Linux/Unix only)                       *config_tmux*


If Neovim is running R in an external terminal emulator, R will run in a Tmux
session with a specially built Tmux configuration file. If you want to use
your own ~/.tmux.conf, put in your config:
>lua
   config_tmux = false
<
If you opted for using your own configuration file, the plugin will write a
minimum configuration which will set the value of environment variables
required for the communication with R and then source your own configuration
file (~/.tmux.conf).


------------------------------------------------------------------------------
6.14. Control of R window                                   *rconsole_height*
                                                            *rconsole_width*
                                                            *min_editor_width*

When starting R, Neovim's buffer is split vertically if its width is larger
than:
>
   min_editor_width + rconsole_width + 1 + (&number * &numberwidth)
<
That is, if it is large enough to guarantee that both the script and the R
windows will have at least the desired number of columns even if 'number' is
set. The default value of both `min_editor_width` and `rconsole_width` is
80. If you prefer the window is always split vertically, set these two options
with lower values in your config. Example:
>lua
   rconsole_width = 57
   min_editor_width = 18
<
If you always prefer a horizontal split, set the value of `rconsole_width`
to 0:
>lua
   rconsole_width = 0
<
For a horizontal split, you can set the number of lines of the R window:
>lua
   rconsole_height = 15
<
You should set 'nosplitright' if you wanted the R Console on the left side,
and 'nosplitbelow' if you wanted it above the R script.

Note: If running R in a Neovim buffer, the number of lines and columns will
automatically change if you switch between horizontal and vertical splits (see
|CTRL-W_K| and |CTRL-W_H|). You may request Neovim to try to keep the minimum
width and height of a specific window by setting the options 'winwidth' and
'winheight'. So, if the window is split horizontally and you want a small R
Console window, you should set a large value for 'winheight' in the script
window.


------------------------------------------------------------------------------
6.15. Integration with RStudio                                   *RStudio_cmd*

If you want to run RStudio instead of R, set in your config the value of
`RStudio_cmd` to the complete path of the RStudio_cmd binary. Example:
>lua
   RStudio_cmd = "C:\\Program Files\\RStudio\\bin\\rstudio"
<
Note: On Windows, you must manually run a successful comand in RStudio Console
before sending code from Neovim to RStudio. The command might be something as
simple as the number `1`.


------------------------------------------------------------------------------
6.16. Special R functions                                        *listmethods*
                                                                 *specialplot*

The R function `args()` lists the arguments of a function, but not the
arguments of its methods. If you want that the plugin calls the function
`nvim.list.args()` after <LocalLeader>ra, you have to add to your config:
>lua
   listmethods = true
<
By default, R makes a scatter plot of numeric vectors. The function
`nvim.plot()` do both a histogram and a box plot. The function can be called
by the plugin after <LocalLeader>rg if you put the following line in your
config:
>lua
   specialplot = true
<

------------------------------------------------------------------------------
6.17. Control how paragraphs and lines are sent              *parenblock*
                                                             *paragraph_begin*
                                                             *bracketed_paste*
                                                             *clear_console*

If a line has an opening parenthesis, all lines up to the closing parenthesis
are sent to R when you send a line of code to R. If you prefer to send the
lines one by one, put in your config:
>lua
   parenblock = false
<
By default, when you press <LocalLeader>pp R.nvim sends all contiguous lines
to R, that is all lines above and below the current one that are not separated
by an empty line. If you prefer that only lines from the cursor position to
the end of the paragraph are sent, put in your config:
>lua
   paragraph_begin = false
<
Bracketed paste mode will bracket R code in special escape sequences when it
is being sent to R so that R can tell the differences between stuff that you
type directly to the console and stuff that you send. It is particularly
useful when you are using a version of R which is compiled against readline
7.0+. To enable it, put in your config:
>lua
   bracketed_paste = true
<
Some versions of R's console interpret <C-L> as a command to clear the console
while others have no command to clear the console. You should set the value of
`clear_console`  as `false` if you see `^L` printed in the R's console after
<LocalLeader>rm:
>lua
   clear_console = false
<

------------------------------------------------------------------------------
6.18. Arguments to R source() function                       *source_args*
                                                             *max_paste_lines*

When you send multiple lines of code to R (a selection of lines, a paragraph,
code between two marks or an R chunk of code), and the number of lines is
higher than `max_paste_lines`, R.nvim saves the lines in a temporary file and,
then, sends to R a command which calls `base::source()` to run the commands
from the temporary file.

By default, R's `source()` is called with the arguments `print.eval=TRUE` and
`spaced=FALSE`. The argument `local=parent.frame()` is passed to `source()`
too because it is run inside another function. But you can either add or
change the arguments passed to it. Examples:
 >lua
   source_args = "echo = TRUE"
   source_args = "print.eval = FALSE, echo = TRUE, spaced = TRUE"
<
You can set the maximum number of lines to be directly pasted into the R
Console with the option `max_paste_lines` (default value = 20).


------------------------------------------------------------------------------
6.19. LaTeX options                                               *sweaveargs*
                                                                  *latexcmd*
                                                                  *texerr*

To produce a PDF document from the .tex file generated by either `Sweave()` or
`knit()` command, R.nvim calls:
>
   latexmk -pdf -pdflatex="xelatex %O -file-line-error -interaction=nonstopmode -synctex=1 %S"
<
If `xelatex` is not installed, it will be replaced with `pdflatex` in the
above command. If `latexmk` is not installed, R.nvim will call either
`xelatex` or `pdflatex` directly.

To change this behavior, you can set the value `latexcmd` which is a list
whose first element is the command to be executed and the remaining elements
are arguments to be passed to the command. Examples:
>lua
   latexcmd = { "xelatex" }
   latexcmd = { "pdflatex", "-interaction=nonstopmode", "-synctex=1" }
   latexcmd = { "latexmk", "-pdf", '-pdflatex="xelatex %O -synctex=1 %S"' }
<
The elements of `latexcmd` may contain double quotes (as in the last example
above), but not single quotes, because R.nvim will use single quotes to
separate them in an R's `c()` command.

If you want to pass arguments to the `Sweave()` function, set the value of the
`sweaveargs` variable.

If the value of `texerr` is `true`, nvmimcom will output to R Console LaTeX
errors and warnings produced by the compilation of the .tex document into
.pdf. So, you do not have to scroll the R Console seeking for these messages.
However, if R.nvim cannot not find the LaTeX log file because it is not saved
in the same directory as the Rnoweb, you should set the value of
`latex_build_dir`. Example:
>lua
   latex_build_dir = "build"
<

------------------------------------------------------------------------------
6.20. rmarkdown::render() options                            *rmd_environment*
                                                             *rmarkdown_args*

When rendering an Rmd file, the code can be evaluated (and saved) in a
specified environment.  The default value is `.GlobalEnv` which makes the
objects stored in the Rmd file available on the R console.  If you do not want
the objects stored in the Rmd file to be available in the global environment,
you can set
>lua
    rmd_environment = "new.env()"
<
Other options to be passed to `rmarkdown::render()` might be defined with
`rmarkdown_args`, as in the example:
>lua
   rmarkdown_args = "output_dir = 'output', clean = FALSE"
<

------------------------------------------------------------------------------
6.21. Quarto's render and preview options                *quarto_render_args*
                                                         *quarto_preview_args*

If you want to send the commands `quarto::quarto_render()` and
`quarto::quarto_preview()` to R with additional arguments, you should define
the values of `quarto_render_args` and `quarto_preview_args` in your
config, as in the examples:
>lua
   quarto_render_args = ", pandoc_args = c('-F', 'apafix.py')"
   quarto_preview_args = ", browse = FALSE"
<

------------------------------------------------------------------------------
6.22. Clear R Console line before sending commands              *clear_line*
                                                                *editing_mode*

When one types <C-a> in the R Console the cursor goes to the beginning of the
line and when one types <C-k> the characters to the right of the cursor are
deleted. This is useful to avoid characters left on the R Console being mixed
with commands sent by Neovim. But R.nvim does not do this by default because
control characters may cause problems in some circumstances. Hence, if you
want that R.nvim adds <C-a><C-k> to every command put in your config:
>lua
   clear_line = true
<
R.nvim reads your `~/.inputrc` and, if it finds the string "set editing-mode
vi" it will send to R <Esc>0Da instead of <C-a><C-k>. If R.nvim fails to
detect that R is running in vi editing mode, you have to put this line in your
config:
>lua
   editing_mode = "vi"
<
This might produce a beep when sending commands, and you may want to disable
the audible bell only for R by putting in your `~/.inputrc`:
>
   $if R
       set bell-style none
   $else
       set bell-style audible
   $endif
<
Note: You can't control the bell on Windows; it is hardcoded to run in Rterm
and to not run in Rgui.


------------------------------------------------------------------------------
6.23. Open document generated from quarto, rnoweb or rmd files     *pdfviewer*
                                                                   *open_pdf*
                                                                   *open_html*

The plugin can automatically open the PDF file generated by pdflatex, after
either `Sweave()` or `knit()`. This behavior is controlled by the variable
|open_pdf| whose value may be "no" (do not open the PDF), "open" (open the
PDF, but don't focus its window), "open and focus" (open the PDF and focus the
PDF viewer window after generating the document). For example, if you want
that the PDF application is started automatically but do not want the terminal
losing focus every time that you generate the PDF, you should put in put in
your config:
>lua
   open_pdf = "open"
<
The default value of `open_pdf` is "open and focus" but support for focusing
the PDF viewer window was not implemented for all systems. Currently, it works
only on the X Server and on the Sway Window Manager. On Linux, if running on
the X server (not on Wayland), the application `wmctrl` is required to raise
both the PDF viewer and Neovim windows. This feature is not implemented for
Wayland windows managers other than Sway.

R.nvim will call Sumatra to open the PDF on Windows, Skim on macOS, and
Zathura on Linux, but you can change the values of `synctex` and `pdfviewer`
in your config if you don't need SyncTeX support. Setting `pdfviewer` to an
empty string will open the PDF with the OS default application. Examples:
>lua
   synctex = false
   pdfviewer = "evince"   -- Use Evince as PDF viewer
   pdfviewer = ""         -- Default PDF viewer (and no SyncTeX support)
<
If editing an Rmd file, you can produce the html result with <LocalLeader>kr
or <LocalLeader>kh (it may also work with other file types). The html file
will be automatically opened and the browser window focused. You can control
this with the option `open_html` whose values are the same of `open_pdf`:

   "no": Never open the html in a browser.
   "open": Open the html in a browser, but don't focus it.
   "open and focus": Focus the browser window after generating the html.


The browser application called by R.nvim is whatever string is returned by the
R command `getOption("browser")`. If the option "browser" is `NULL`, R.nvim
will call `open` on both Windows and macOS, and `xdg-open` on Linux. If it is
an R function, R.nvim will send the command `browseURL()` to R.

Note: R.nvim tracks the browser PID to know that it is open and to try to
focus its window. This means that if either `open` or `xdg-open` was callled
instead of the browser directly, R.nvim will not know the browser's PID. This
can be fixed by setting the "browser" option in the `~/.Rprofile`. Also, most
browser will reuse any open window and close immediately. Consequently, R.nvim
will consider that the browser was closed and will to open it again.

For Quarto documents, the available key bindings are <LocalLeader>qr (render
document), <LocalLeader>qp (preview document), and <LocalLeader>qs (stop
previewing). The command <LocalLeader>kr achieves basically the same result of
<LocalLeader>qr. The difference is that the generated document is open after
<LocalLeader>kr, and <LocalLeader>qr allows Quarto specific
options (see |quarto_render_args|).


------------------------------------------------------------------------------
6.24. Allow R commands in insert mode                     *insert_mode_cmds*

R.nvim commands are enabled for Normal mode, but most of them can also be
enabled in Insert mode:
>lua
   insert_mode_cmds = true
<

------------------------------------------------------------------------------
6.25. Show/remove hidden objects                                  *rmhidden*

Hidden objects are removed from R workspace when you do <LocalLeader>rm. If
you prefer to remove only visible objects, put in your config:
>lua
   rmhidden = false
<
After removing the objects, R.nvim will also send CTRL-L to the R Console to
clear the screen. If you have set vi mode in your `~/.inputrc` you might also
want to set CTRL-L to clear the screen, as explained at

https://unix.stackexchange.com/questions/104094/is-there-any-way-to-enable-ctrll-to-clear-screen-when-set-o-vi-is-set


------------------------------------------------------------------------------
6.26. Time to wait for nvimcom loading                                *wait*

R.nvim asynchronously waits 60 seconds for the nvimcom package to be loaded
during R startup. If 60 seconds are not enough to your R startup, then set a
higher value for the variable in your config. Example:
>lua
   wait = 100
<

------------------------------------------------------------------------------
6.27. Start R in working directory of Neovim                           *setwd*

If you want that R starts in the directory of the file that you are editing,
put in your config:
>lua
   setwd = "file"
<
If you want that R starts in Neovim's working directory, put in your config:
>lua
   setwd = "nvim"
<
The default value of `setwd` is "no". See also 'autochdir'.


------------------------------------------------------------------------------
6.28. Custom Lua functions to be executed on specific moments           *hook*

If you want the execution of a Lua function just after the configuration is
finished for each buffer, after the global plugin configuration, R startup or
the Object Browser opening, set the `hook` config option, as in the example
below:
>lua
   hook = {
       on_filetype =  function() vim.notify("R.nvim FileType event") end,
       after_config = function() vim.notify("R.nvim is configured") end,
       after_R_start = function() vim.notify("R was launched") end,
       after_ob_open = nil,
   },
<
See |R.nvim-key-bindings| for a real example of how to use the `after_config`
hook.


------------------------------------------------------------------------------
6.29. Disable R.nvim commands                                 *user_maps_only*
                                                              *disable_cmds*
                                                              *filetypes*

The R.nvim sets many default key bindings, but you can change them to custom
key bindings (|R.nvim-key-bindings|). If you wish R.nvim to only use the
key-bindings that you have specified, put in your config:
>lua
    user_maps_only = true
<
If you want to disable only some of R.nvim commands, create a Lua `string[]`
table with their key bindings <Plug> labels in your config. The complete list
of key bindings labels is shown with the command:
>vim
   :RMapsDesc
<
Below is an example on how to disable the commands that send `setwd()` and
`dput()` to R Console:
>lua
   disable_cmds = { "RSetwd", "RDputObj" }
<
If you want to disable R.nvim for a specific file type, create the variable
`R_filetypes` with a list of file types that should be supported. Example:
>lua
   vim.g.R_filetypes = { "r", "rmd", "rnoweb", "quarto", "rhelp" }
<
If the variable `R_filetypes` does not exist, all file types from the above
list will be supported.


------------------------------------------------------------------------------
6.30. Temporary files directories                                   *tmpdir*
                                                                    *compldir*

You can change the directories where temporary files are created and
stored by setting in your config the values of `tmpdir` and
`compldir`, as in the example below:
>lua
   tmpdir = "/dev/shm/R_tmp_dir"
   compldir = "~/.cache/R.nvim"
<
The default paths of these directories depend on the operating system. If you
want to know what they are, while editing an R file, do in Normal mode:
>vim
   :RConfigShow tmpdir
   :RConfigShow compldir
<

------------------------------------------------------------------------------
6.31. Options for accessing Remote R from local Neovim        *remote_compldir*

See https://github.com/R-nvim/R.nvim/wiki/Remote-access


------------------------------------------------------------------------------
6.32. View a data.frame or matrix                                    *view_df*


You can see data.frames and matrices in external applications with
<LocalLeader>rv. By default, R.nvim will generate a `tsv` file from the whole
`data.frame` or `matrix` and paste its contents it in a new tab. But you can
change this by setting the values of the `view_df` elements in your config.
The default values are:
>lua
   view_df = {
      open_app = "",  -- How to open the CSV
      how = "tabnew", -- How to display the data if doing it within Neovim
      csv_sep = "",   -- Field separator to be used when saving the CSV.
      n_lines = -1,   -- Number of lines to save in the CSV (0 for all lines).
      save_fun = "",  -- R function to save the data.frame in a CSV file
      open_fun = "",  -- R function to open the data.frame directly
                      -- (no conversion to CSV needed)
   },
<
If `open_app` begins with "terminal:", R.nvim will open a new tab with the
application running in a terminal emulator. For example, if you want to use
Visidata to see tabular data, put in your config:
>lua
   open_app = "terminal:vd"
<
If you are running Neovim within Tmux, you may prefer:
>lua
   open_app = "tmux new-window vd"
<
If `open_app` begins with ":", R.nvim will append the name of the tsv file
and |:execute| the command. Example:
>lua
   open_app = ":vsplit"
<
You may also include "%s" in `open_app` to indicate the position of the tsv
file name in the command to be executed. Example using the `toggleterm.nvim`
plugin which requires the whole command within quotes:
>lua
   open_app = ':TermExec cmd="vd %s"'
<
You may also try to see the table in a graphical viewer such as LibreOffice
Calc:
>lua
   open_app = "localc"
   open_app = "c:/Program Files (x86)/LibreOffice 4/program/scalc.exe"
<

The substring `%s` is replaced by the name of the object under the cursor, and
`()` are added if necessary. In this case, no `csv` file is saved (see also
|R.nvim-key-bindings|).

The data will be displayed in a new tab. Change the value of `how` to "split"
or "vsplit" to display the data in a split window.

If the default field delimiter (`\t`) causes problems in your case, you can change it
in your config. Valid values are `"\t"`, `";"` and `","`. Example:
>lua
   csv_sep = ","
<
By default, the `tsv` file is got by capturing the output of `write.table()`.
This has the advantage of depending only on base R. The data is streamed
through nvimcom's TCP connection to ensure that it will work if R is running
remotely. If this is too slow for the size of your data sets, or if you want
to display more lines of data, you will want to change other `view_df`
options, such as `save_fun` (see example below).

If the value `n_lines` is `-1`, the maximum number of lines displayed will be:
>r
   ceiling(10000 / number_of_columns)
<
Set the value of `n_lines` to `0` to display all lines or to any positive
integer number to set a fixed maximum.

If are not running R remotely and want the CSV file written more quickly, you
can define the function to save the CSV. In this case, the data will be saved
in a file instead of streamed. The function must receive the `data.frame` as
the first argument and the file name as the second argument and should return
the name of the saved file. Examples:

Use `data.table` to save a TSV file:
>lua
   view_df = {
     n_lines = 0,
     save_fun = "function(obj, obj_name) {f <- paste0('/tmp/', obj_name, '.tsv'); data.table::fwrite(obj, f, sep = '\t') ; f}",
   }

Use `arrow` to save a parquet file, and VisiData to open it:
>lua
   view_df = {
     n_lines = 0,
     save_fun = "function(obj, obj_name) {f <- paste0(obj_name, '.parquet'); arrow::write_parquet(obj, f) ; f}",
     open_app = "terminal:vd"
   }
<
Finally, instead of either streaming or saving the `data.frame`, there is also
an option to configure R.nvim to send a command to the R Console to display
the data. Examples:
>lua
   open_fun = "tibble::tibble"
   open_fun = "relimp::showData(%s, font = 'Courier 14')"
<

------------------------------------------------------------------------------
6.33. SyncTeX support                                         *R.nvim-SyncTeX*

SyncTeX is a communication system used by some PDF viewers and by some text
editors which allow users to jump from a specific line in the text editor to
the corresponding line in the PDF viewer and vice-versa. R.nvim has support
for SyncTeX in three applications:

   Linux:   Zathura
   macOS:    Skim
   Windows: SumatraPDF

To completely disable SyncTeX support, put in your config:
>lua
   synctex = false
<
Note: The knitr package (as of version 1.7) had at least two limitations:

   - It had no SyncTeX support for child documents. The correspondence data
     point to lines right below child chunks in the master document and not to
     somewhere in the child documents themselves. See:
     https://github.com/yihui/knitr/issues/225

   - It only started registering the concordance after the first chunk. So, it
     is recommended that you put the first chunk of R code just after the
     `\begin{document}` command.


------------------------------------------------------------------------------
6.34. .Rproj support                                        *rproj_prioritise*

When a R.nvim buffer (e.g. an R script) is first opened, certain
buffer-specific variables may be set which will reflect the settings in the
relevant .Rproj file. The advantage of this approach is that a user can jump
between R projects that may have different settings and the behaviour of
R.nvim will continue to be appropriate for each script. The option
`rproj_prioritise` is a string table listing the `.Rproj` options that should
override the default `R.nvim` options. Currently, it has only one valid
option:
>lua
  rproj_prioritise = { "pipe_version" }


------------------------------------------------------------------------------
6.35. Convert numbers to explicit integers                 *convert_range_int*

The `lintr` package (https://lintr.r-lib.org/https://lintr.r-lib.org/)
provides a way to check R code for common style issues. This section describes
how "R.nvim" helps you use `lintr` in your code to improve its readability.

It is good practice to use the `L` suffix when referring to integers in R
(e.g. `1L`). If you want to convert all numbers to explicit integers in the
current buffer, you can use `<LocalLeader>cn` (change number). By default,
this will not change numbers in a range (e.g. `1:10`). To allow changing
numbers in a range (`1:10` -> `1L:10L`), put the following in your
configuration:
>lua
  convert_range_int = true


------------------------------------------------------------------------------
6.36. Convert extraction operators                  *convert_extract_operator*

There are two types of subsetting expressions in R: `$` and `[.` `R.nvim`
allows to convert the subsetting operators `[` and `$` to `[[`.

   1. First case, when using the `$` operator: `df$var -> df[["var"]]`.
   2. Second case, when using the `[` operator: `vec[1] -> vec[[1]]`.

The default key binding for this functionally is `<LocalLeader>cs` (change
subsetting).


------------------------------------------------------------------------------
6.37. Installing missing R packages in the current buffer    *install_missing*

If the `lintr` package is installed and properly configured
(https://github.com/R-nvim/R.nvim/wiki/lintr), it will mark any R packages
used in the current buffer that are not installed as missing. These missing
packages can be automatically installed using the `<LocalLeader>ip` (install
packages) key binding.


------------------------------------------------------------------------------
6.38. Split file paths and URLs                                   *split_path

You can split the path of the current file, directory, or a URL under the
cursor into its components (e.g., directory, file name, extension) using the
`<LocalLeader>sp` key binding. If the target string is detected as a file or a
path, it will be split using the `/` character (e.g., Unix-like paths) and
processed using a specified function designed to handle paths safely. By
default, the `split_path_fun` is set to `file.path`. To use a different
function, you can configure the `split_path_fun` value in your settings.
Current available functions are:
>lua
  path_split_fun   = { "here::here", "here", "file.path", "fs::path", "path" }

If the target string is detected as a URL, it will be split using the '/' character.
will be handled using the `paste0()` function.


------------------------------------------------------------------------------
6.39. Tree-sitter parser for Quarto and RMarkdown        *register_treesitter*

R.nvim registers the Markdown parser to both Quarto and RMarkdown documents.
This will change in the future if dedicated parsers are written for them.
You can disable this feature in your R.nvim config:
>lua
  register_treesitter = false


------------------------------------------------------------------------------
6.40. Set `params` based on the YAML header                       *set_params*

Set `params` based on the YAML header for R Markdown and Quarto documents.
Defaults to `"yes"`. Valid values:

   `"no"`:          Don't create the object `params` in the `.GlobalEnv`.
   `"no_override"`: Create the object `params` only if it doesn't exist yet.
   `"yes"`:         Create and override the object `params` whenever the
                  corresponding YAML field changes.


------------------------------------------------------------------------------
6.41. Support for debugging functions                                *debug*

Put the line below in your config if do not want that the cursor jumps to the
line being debugged (when `browser()` is run). Highlighting of the line being
debugged will also be disabled.
>lua
   debug = false
<
R.nvim puts the cursor in the R Console when the debugging starts. If you do
not want this, put in your config:
>lua
   debug_jump = false
<
The highlighted debugged line incrementally moves down the buffer with code
execution and, with long scripts, it may stay at the bottom of the window as you
debug. You can hold the highlighted line in the middle of the window with
>lua
    debug_center = true
<

==============================================================================
7. Public Lua API                                             *R.nvim-lua-api*

The Lua internals for R.nvim should be considered generally unstable and
subject to change without notice. There are some exceptions to this rule,
which are declared stable for the benefit of users:

r.run.action(rcmd, mode, args)                                 *r.run.action()*
    Calls an R function on the word currently under the cursor

    Parameters: ~
        {rcmd} (string)     The name of an R function
        {mode} (string)     The current mode (`"n"` or `"v"`)
        {args} (string)     Extra arguments to pass to `rcmd`

r.send.cmd(command)                                              *r.send.cmd()*
    Calls an R function on the word currently under the cursor

    Parameters: ~
        {command} (string)  Code to send to the current R session

See in the next section examples of using the API within the `on_filetype`
hook.
<

==============================================================================
8. Custom key bindings                                   *R.nvim-key-bindings*

See |user_maps_only| if you want to inhibit the creation of default mappings.
See |disable_cmds| if you only want to avoid the creation of some of them.

When creating custom key bindings for R.nvim, you have to create a map to a
<Plug>Label which is mapped to the actual function to be executed. That is,
you create the first link of the complete key mapping:
>
   Key_combination ---> <Plug>Label ---> Command
<
To see the description of all key combinations and their respective
<Plug>Labels, do in Normal mode:
>vim
   :RMapsDesc
<
You may close the window opened by `:RMapsDesc` by simply pressing `q`. The
prefix "RD" in the labels means "cursor down".

If `user_maps_only = true`, no `Key_combination --> <Plug>Label` is
automatically created and the remaining `<Plug>Label ---> Command`
becomes harmless.

Whether you have set `user_maps_only` to `true` in your R.nvim config or just
want to change the default key combination of some key mappings, the
`on_filetype` hook from `R.nvim` config is a good place to add your custom key
bindings. Examples:
>lua
   hook = {
       on_filetype = function()
           -- Use <Enter> to send code to R:
           vim.api.nvim_buf_set_keymap(0, "n", "<Enter>", "<Plug>RDSendLine", { noremap = true })
           vim.api.nvim_buf_set_keymap(0, "v", "<Enter>", "<Plug>RSendSelection", { noremap = true })

	   -- Emulate some of Nvim-R's default key bindings:
           vim.api.nvim_buf_set_keymap(0, "i", "_", "<Plug>RInsertAssign", { noremap = true })
           if vim.bo.filetype == "rnoweb" then
               vim.api.nvim_buf_set_keymap(0, "i", "<", "<Plug>RnwInsertChunk", { noremap = true })
           elseif vim.bo.filetype == "rmd" or vim.bo.filetype == "quarto" then
               vim.api.nvim_buf_set_keymap(0, "i", "`", "<Plug>RmdInsertChunk", { noremap = true })
           end
       end,
   }
<
The plugin contains a function called `action` in the Lua module `r.run`
which allows you to build ad-hoc commands to R. This function takes the name
of an R function such as "levels" or "table" and the word under the cursor,
and passes them to R as a command. For example, if your cursor is over the
object called "gender" and you call the `action` function, with the argument
"levels", Neovim will pass the command `levels(gender)` to R. To make it even
easier to use this and other functions, you could write custom key bindings
inside the function passed to `hook.on_filetype` as in the examples below
(see |hook|):
>lua
   hook = {
       on_filetype = function()
           vim.api.nvim_buf_set_keymap(0, "n", "<LocalLeader>L", "<Cmd>lua require('r.run').action('levels')<CR>", {})

           -- If you want an action over a selection, then the second
           -- argument must be the string `"v"`:
           -- In this case, the beginning and the end of the selection must be
           -- in the same line.
           vim.api.nvim_buf_set_keymap(0, "v", "<LocalLeader>T", "<Cmd>lua require('r.run').action('head')<CR>", {})

           -- If a third optional argument starts with a comma, it will be
           -- inserted as argument(s) to the `action`:
           vim.api.nvim_buf_set_keymap(0, "n", "<LocalLeader>H", "<Cmd>lua require('r.run').action('head', 'n', ', n = 10')<CR>", {})

           -- If the command that you want to send does not require an R
           -- object as argument, you can use `cmd()` from the `r.send` module
           -- to send it directly to R Console:
           vim.api.nvim_buf_set_keymap(0, "n", "<LocalLeader>S", "<Cmd>lua require('r.send').cmd('search()')<CR>", {})

	   -- Close the last graphics window:
	   vim.api.nvim_buf_set_keymap(0, "n", "cw", "<Cmd>lua require('r.send').cmd('dev.off()')<CR>", { noremap = true })
       end,
   }



==============================================================================
9. History                                                    *R.nvim-history*

See: https://www.vim.org/scripts/script.php?script_id=2628
     https://groups.google.com/g/vim-r-plugin
     https://github.com/jcfaria/Vim-R-plugin
     https://github.com/jalvesaq/Nvim-R
     https://github.com/R-nvim


vim:tw=78:ts=8:ft=help:norl
